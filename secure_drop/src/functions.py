################################################ IMPORTS ################################################

from Crypto.Cipher import AES
import Crypto.Protocol.KDF
import Crypto.Random
import Crypto.Util.Counter
import os
import base64
import getpass
import random
import string
import stat
import sys
from Crypto import Random
from Crypto.Cipher import AES
import hashlib

############################################### VARIABLES ###############################################

# SIZE OF THE SALT
salt_size = 16
# RANDOM SALT FOR KEY TO MAKE BRUTEFORCE HARDER
salt_for_key = os.urandom(salt_size)
# THIS GIVES US THE CURRENT DIRECTORY
DIR = os.path.dirname(__file__)
# WE DEFINE OUR FILES FOR STORING KEY
frozen = 'not'
if getattr(sys, 'frozen', False):
        bundle_dir = sys._MEIPASS
        print bundle_dir
else:
        # WE ARE RUNNING IN A NORMAL PYTHON ENVIRONMENT
        bundle_dir = os.path.dirname(os.path.abspath(__file__))

# THIS IS THE FILE IN WHICH WE SAVE OUR KEY
KEY_FILE = os.path.abspath(os.path.join(bundle_dir, "key_file.txt"))

############################################ HELPER FUNCTIONS ###########################################

def save_key(password):
    """
    This functions is called to save key to key_file.txt.
    """
    # WE USE PBKDF1 TO DERIVE A KEY FROM THE  KEY INPUT TAKEN FROM USER
    # 32 IS THE KEY LENGTH
    # 2000 IS NUMBER OF ITERATIONS (MINIMUM RECOMMENDED IS 1000)
    key =Crypto.Protocol.KDF.PBKDF2(password, salt_for_key, 32, 2000)
    # AFTER CREATING A DERIVATED KEY, WE SAVE IT TO THE FILE WITH THE SALT ADDED TO IT
    key_file = open(KEY_FILE, 'w')
    key_file.write(base64.b64encode(salt_for_key) + ":"+ base64.b64encode(key))
    key_file.close()


def read_key():
    """
    This functions is used to read key from key_file.txt.
    """
    # WE OPEN  KEY FILE, AND SEPATAE IT WITH ":"
    # THEN WE RETURN BOTH SALT AND PASSWORD
    with open(KEY_FILE,'r') as f:
        line = f.readline()
        pair = line.split(":")
        return base64.b64decode(pair[0]), base64.b64decode(pair[1])


def create_key():
    """
    This functions gets input from the user for key.
    """
    # WE TAKE KEY INPUT FROM THE USER AND MAKE SURE HE/SHE ENTERS IT TWO TIMES TO AVOID TYPOS
    # WE HAVE KEY AT LEAST BE 6 CHARACTERS
    # AFTER THAT, WE CALL save_key FUNCTION WITH THE PARAMETER password
    while 1:
        password = ""
        password = getpass.getpass("Please create password (at least 6 character):");
        if len(password) < 6:
            print "ERROR: password key should be at least 6 characters!"
        else:
            confirmation_password = getpass.getpass("Please retype it:");
            if password != confirmation_password:
                print "ERROR: Does not match!"
            else:
                save_key(password)
                break


def auto_generate_key():
    """
    This functions automatically generates password.
    """
    # IF USER WANTS AUTOGENERATE OPTION, WE AUTOGENERATED 12 CHARACTER PASSWORD FOR HIM/HER
    # AND WE CREATE KEY ACCORDINGLY
    password = base64.b64encode(str(Crypto.Random.new().read(12)));
    save_key(password)
    print "Your password: ", password



def ask_key():
    """
    This functions is used to authenticate the user.
    """
    # WE ASK PASSWORD TO THE USER TO AUTHENTICATE
    # AFTER GETTING THE INPUT, WE ENCRYPT IT IN THE SAME WAY, AND COMPARE IT WITH THE PASSWORD SAVED IN THE FILE
    password_input = getpass.getpass("To Login, Please enter password:")
    saved_salt,saved_password = read_key()
    password_input_key = Crypto.Protocol.KDF.PBKDF2(password_input, saved_salt, 32, 2000)
    if password_input_key == saved_password:
        return True
    else:
        return False



def check_key(): 
    """
    This functions is used to check if the user has key.
    """
    # WE CHECK IF THE USER ALREADY HAS A KEY
    key=""
    with open(KEY_FILE,'r') as f:
        key = f.readline()
        if key == "":
            return False
        else:
            return True



def ask_options(): 
    """
    This functions gives options for the main menu
    """
    op = raw_input("To upload a file, enter 1\nTo download a file, enter 2\nTo exit, enter 3:\n")
    return op


def create_key_file(): 
    """
    This functions is called to create key_file.txt
    Permissions of the files are changed, so only the owner of the files can read from and write to the files.
    """
    if os.path.isfile(KEY_FILE)!= True :
        file_passwd = open(KEY_FILE, 'w+')
        file_passwd.close()
        os.chmod(KEY_FILE, stat.S_IREAD | stat.S_IWRITE)


def ask_to_create_key():
    """
    This functions is called to ask if user wants auto generated key or not
    """
    option = raw_input("We need to create password\nIf you want auto generated, enter 1\nIf you want to create it manually, enter 2: ")
    return option.strip()



def pad(content):
    """
    This functions is used to pad the file content is the length of the file is not appropriate for CBC
    """
    # WE PAD THE FILE WITH "\0" BYTES
    padded = content + b"\0" * (AES.block_size - len(content) % AES.block_size)
    return padded

def encrypt_file(file_name, key):
    """
    This functions is used to encrypt the file content with CBC mode, and to sign the file encrypted content to protect integrity
    """
    # FIRST WE CHECK IF THE FILE EXIST OR HAS ANY CONTENT. IF IT DOES NOT EXIST OR EMPTY, WE DO NOT APPLY ENCRYPTION.
    FILE_r = os.path.abspath(os.path.join(bundle_dir, file_name))
    flag = 1
    try:
        with open(FILE_r, 'rb') as f:
            content = f.read()
    except IOError:
        print "Could not read file:", FILE_r
        flag = 0
        
    if flag == 0:
        return 0
    else:
        if len(content)==0:
            return 0
        else:

            #IF THE FILE HAS CONTENT, FIRST WE PAD IT.
            #THEN WE CREATE IV VALUETO USE IN OUR CBC MODE ENCRYPTION
            #THEN WE CREATE OUR CIPHER OBJECT BY USING AES CLASS WITH PARAMETERS (OUR KEY, CBC MODE, AND IV)
            #THEN WE ENCRYPT THE CONTENT AND WE INTEGRATE IT WITH OUR IV VALUE

            content = pad(content)
            iv = Random.new().read(AES.block_size)
            cipher = AES.new(key, AES.MODE_CBC, iv)
            encrypted_content = iv + cipher.encrypt(content)

            #AFTER ENCRYPTION, WE CREATE MD5 OBJECT TO SIGN OUR ENCRYPTED CONTENT
            md5 = hashlib.md5()
            md5.update(encrypted_content)

            # WE KEEP TRACK OF OUR FILE EXTENTION BECAUSE WE CAN ENCRYPT DIFFERENT FILES SUCH AS .TXT .JPG .PDF ETC.
            # ALTHOUGH WE UPLOAD OUR ENCRYPTED CONTENT TO DROPBOX, WE ALSO KEEP A LOCAL COPY IN OUR LOCAL COMPUTER
            extension = file_name[-4:]
            encrypted_name = file_name[:len(file_name)-4] + "_encrypted_local" + extension

            FILE_w= os.path.abspath(os.path.join(bundle_dir, encrypted_name))

            #WE WRITE ENCRYPTED CONTENT + SIGNATURE TO LOCAL FILE AND SAVE IT AS LOCAL COPY
            with open(FILE_w, 'wb') as f_out:
                f_out.write(encrypted_content + md5.hexdigest())
                print "ENCRYPTED local copy is here  " + FILE_w

             #WE RETURN ENCRYPTED CONTENT + SIGNATURE TO CALLER AND THE CALLER UPLOAD IT TO DROPBOX   
            return encrypted_content + md5.hexdigest()


def decrypt_file(file_name, key):
    # FIRST WE READ THE ENCRYPTED FILE WHICH IS DOWNLOADED FROM DROPBOX

    FILE_r= os.path.abspath(os.path.join(bundle_dir, file_name))

    with open(FILE_r, 'rb') as f:
        ciphertext = f.read()

    # BEFORE DECRYPTING THE FILE, WE CHECK ITS SIGNATURE TO CHECK THE INTEGRITY
    # LAST 32 CHARACTERS ARE THE SIGNATURE
    
    md5 = hashlib.md5()
    encrypted_content = ciphertext[:len(ciphertext)-32]
    md5.update(encrypted_content)

    # WE FIND IV IN THE ENCRYPTED CONTENT, AND CREATE OUR AES OBJECT TO USE IT FOR DECRYPTION
    iv = encrypted_content[:AES.block_size]
    cipher = AES.new(key, AES.MODE_CBC, iv)

    # IF THE LENGTH OF THE ENCRYPTED CONTENT IS NOT APPROPRIATE, WE KNOW THE INTEGRITY IS VIOLATED
    if len(encrypted_content[AES.block_size:])%16!=0:
        print "integrity violated. Cipher is not multiple of 16 in length"
        sys.exit("Bye, bye!")   
    else: 

        # WE TAKE THE BYTES UNTIL THE SIGNATURE, WE SIGN THE BYTES AND COMPARE IT WITH THE SIGNATURE
        # IF THEY ARE SAME, THE INTEGRITY IS PROTECTED
        if md5.hexdigest() == ciphertext[-32:]:
            print "INTEGRITY IS PROTECTED"

            #WE DECRYPT THE CONTENT
            content = cipher.decrypt(encrypted_content[AES.block_size:])
            #WE REMOVE THE PADDING CHARACTERS
            decrypted_content = content.rstrip(b"\0")
            #WE KEEP TRACK OF THE EXTENSION TO SAVE OUR DECRYPTED CONTENT
            extension = file_name[-4:]
            decrypted_name = file_name[:len(file_name)-4] + "_decrypted" + extension

            # WE SAVE THE DECRYPTED CONTENT
            FILE_w1= os.path.abspath(os.path.join(bundle_dir, decrypted_name))

            with open(FILE_w1, 'wb') as f_out:
                f_out.write(decrypted_content)
            print "ENCRYPTED file downloaded from dropbox is here " + os.path.abspath(os.path.join(bundle_dir, file_name))
            print "DECRYPTED dropbox file is here " + FILE_w1 + "\n"
        else:
            # IF THEY ARE NOT SAME, THE INTEGRITY IS VIOLATED
            # WE STILL ASK USER IF HE/SHE WANTS TO DECRYPT AFTER WE WARN THE USER ABOUT INTEGRITY VIOLATION
            print "WARNING: INTEGRITY IS VIOLATED!"
            option = raw_input("Do you still want to decrypt?\nFor yes, enter 1\nTo exit, enter 2: ")
            if option == "1":
                #IF THE USER WTILL WANT TO DECRYPT, WE DECRYPT THE CONTENT
                content = cipher.decrypt(encrypted_content[AES.block_size:])
                decrypted_content = content.rstrip(b"\0")

                extension = file_name[-4:]
                decrypted_name = file_name[:len(file_name)-4] + "_decrypted" + extension

                FILE_w2= os.path.abspath(os.path.join(bundle_dir, decrypted_name))

                with open(FILE_w2, 'wb') as f_out:
                    f_out.write(decrypted_content)
                    print "DECRYPTED dropbox file is here " + FILE_w2 + " BUT INTEGRITY WAS VIOLATED.\n"

            elif option =="2":
                # OTHERWISE, WE EXIT
                sys.exit("Bye, bye!")

   


